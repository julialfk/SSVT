module Exercise1 where
import Test.QuickCheck


-- Time spent: 2 hours
-- The type of output that is not yet covered by the given mutators includes for instance the empty list or a singleton list.
-- Perhaps these could be generated by the 'anyList' mutator, but the odds are slim.

-- The precondition of 'anyList' is very weak, as it can take any list possible. The postcondition is also weak because it can return
-- any arbitrary list.
-- The precondition of 'addElements' is the same as 'anyList', however the postcondition is slightly stronger because the structure of the
-- output is defined by its input, while for 'anyList' they are not related at all.
-- The precondition of 'removeEelements' is slightly stronger than the other two mutators, because every though the code will run when
-- you input an empty list, the output will not be different than the input, violating the rules of the mutator. Because of this the
-- precondition is stronger. We think that the postcondition is stronger than that of 'addElements', because the structure of the output
-- is more restricted. This is because only one element is removed, making the output mostly similar to the input, while with
-- 'addElements' this difference can be a lot bigger.

-- Some possible mutations:
  -- Replace one element in the list with an arbitrary number
  -- When the input is non-empty, return an empty list. When the input is empty, return a singleton list.
  -- Reverse list (this only produces a mutant when the list is not mirror-able).
  -- Shuffle list items.
  -- Add one element to the end of the list.
  -- Add one element to the beginning of the list.

-- We would also like to add that the given 'anyList' function has the small chance of returning the same
-- output list as the input, in which the mutator is not in fact a different list.

main :: IO ()
main = do
  print "see comments"

-- Mutate a list by changing one element at a random index. The mutant will always be different
-- because one element changed. We try again recursively in the event of arbitrary generating the same value as the
-- original value on that index.
changeRandomElement :: [Int] -> Gen [Int]
changeRandomElement [] = return []
changeRandomElement xs = do
    index <- choose (0, length xs - 1)
    newValue <- arbitrary
    if xs !! index == newValue
        then changeRandomElement xs -- Recursively call itself
        else return $ take index xs ++ [newValue] ++ drop (index + 1) xs

-- Return an empty list, or a random singleton list if the input list was already empty.
emptyList :: Arbitrary a => [a] -> Gen [a]
emptyList [] = do
              x <- arbitrary
              return [x]
emptyList xs = return []

-- Adds elements to the beginning of an output list. Because the length of the list changes,
-- it will always be different than the input.
addElementsToBegin :: [Integer] -> Gen [Integer]
addElementsToBegin xs = do
  nums <- arbitrary :: Gen [Integer]
  return $ nums ++ xs

-- Adds elements to the end of an output list. Because the length of the list changes,
-- it will always be different than the input.
addElementsToEnd :: [Integer] -> Gen [Integer]
addElementsToEnd xs = do
  nums <- arbitrary :: Gen [Integer]
  return $ xs ++ nums
